# Revocation

Lightning Channel updates rely on revocation to allow peers to trustlessly update the state of the channel, knowing that old state is not safe to broadcast. 

Each peer in a lightning channel maintains their own commitment tx. This way, we can assign blame and allow the aggreived party to take all funds in the channel if the other party broadcasts an old state.

## Revocable transactions

A `to_local` output is an output on a commitment transaction that goes to the holder of that commitment transaction. Both parties will have `to_local` outputs on their respective commitment transactions. `to_local` outputs look like this: 

```
OP_IF
    <revocationpubkey>
OP_ELSE
    <to_self_delay>
    OP_CSV
    OP_DROP
    <local_delayedpubkey>
OP_ENDIF
```

![Commitment Transactions](https://ellemouton.com/lnThings/state1.png#center)

The revocation keys are temporary keys generated by each party, and the public keys are shared to allow both parties to construct eachother's commitment transaction. The actual revocation keys used by LN are more complex than a simple keypair. 

## Updating State

When a channel is first opened, both parties have a commitment transaction with a `to_local` output and a `to_remote` output. When they want to update it, they generate new temporary revocation keys and again share the public keys to allow both parties to construct eachother's new commitment transaction. 

In order to for Alice to update the state and send BTC to Bob, first Alice sends her signature for Bob's new commitment transaction to Bob. Then, she sends her previous revocation private key to Bob, allowing Bob to revoke the previous state if Alice should publish it. Next, Bob also shares his revocation private key with Alice, although, he would have no incentive to do so since alice is giving him money. 

## How Revocation Keys Actually Work

Both parties generate a revocation_basepoint `R = r * G` and a per_commitment_point `C = c * G`

- `RA1 = ra1 * G`
- `RB1 = rb1 * G`
- `CA1 = ca1 * G`
- `CB1 = cb1 * G`

For Alice's commitment tx, Alice sends her Commitment point `CA1` to Bob. Bob sends his revocation basepoint `RB1` to Alice.

Alice generates the revocation point for her commitment tx like so: 

`Rev_A1 = RB1 * sha256( RB1 || CA1) + CA1 * sha256( CA1 || RB1 )`

The corresponding private key would be:

`rev_a1 = rb1 * sha256( RB1 || CA1) + ca1 * sha256( CA1 || RB1 )`

This means that neither party knows the private key. And when Alice wishes to revoke her old state, she shares `ca1` with Bob, but Bob will never share `rb1` with Alice. This means, in the `to_local` script below, Alice will never be able to access. 

```
OP_IF
    <Rev_A1>
OP_ELSE
    <to_self_delay>
    OP_CSV
    OP_DROP
    <local_delayedpubkey>
OP_ENDIF
```

On the opposite side, Alice will give Bob `RA1` and Bob will give Alice `CB1`. Bob can then generate his revocation key like so:

`Rev_B1 = RA1 * sha256( RA1 || CB1) + CB1 * sha256( CB1 || RA1 )`

The corresponding private key would be:

`rev_b1 = ra1 * sha256( RA1 || CB1) + cb1 * sha256( CB1 || RA1 )`

Since Alice will never reveal `ra1`, Bob will never be able to access the `to_local` output on his commitment transaction. 

